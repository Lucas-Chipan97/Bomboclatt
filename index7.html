<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // 🌌 SCENE, CAMERA, RENDERER
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 🔽 Load Textures
        const textureLoader = new THREE.TextureLoader();
        const textures = {
            // Original textures
            earth: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/1/1f/Blue_Marble_Next_Generation.jpg'),
            moon: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/3c/LRO_WAC_Mosaic.jpg'),
            mars: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/0/02/Mars_Valles_Marineris.jpeg'),
            sun: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/3a/Solar_surface_texture.png'),
            saturn: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/6/63/Saturn-true-color.jpg'),
            jupiter: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/e/e2/Jupiter.jpg'),
            uranus: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/3/3d/Uranus.jpg'),
            neptune: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/0/06/Neptune.jpg'),
            saturnRings: textureLoader.load('https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Saturn_rings.png/600px-Saturn_rings.png'),
            
            // Enhanced textures for Sun
            sunNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
            sunEmissive: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/lava/lavatile.jpg'),
            
            // Enhanced textures for Earth
            earthNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_normal_2048.jpg'),
            earthSpecular: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_specular_2048.jpg'),
            earthClouds: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/earth_clouds_2048.png'),
            
            // Enhanced textures for Moon
            moonNormal: textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/moon_normal.jpg'),
        };

        // 🌟 DYNAMIC STAR FIELD
        const starCount = 10000;
        const starGeometry = new THREE.BufferGeometry();
        const starMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.1,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });

        // Create the vertices for stars
        const positions = new Float32Array(starCount * 3);
        const velocities = new Float32Array(starCount);

        for (let i = 0; i < starCount * 3; i += 3) {
            const radius = Math.random() * 2000 + 1000;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            positions[i] = radius * Math.sin(phi) * Math.cos(theta);
            positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
            positions[i + 2] = radius * Math.cos(phi);
            
            velocities[i / 3] = Math.random() * 0.5 + 0.1;
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const starField = new THREE.Points(starGeometry, starMaterial);
        scene.add(starField);

        // 🌞 ENHANCED SUN
        const sunGeometry = new THREE.SphereGeometry(15, 64, 64);
        const sunMaterial = new THREE.MeshStandardMaterial({
            map: textures.sun,
            normalMap: textures.sunNormal,
            emissiveMap: textures.sunEmissive,
            emissive: 0xffaa00,
            emissiveIntensity: 2,
            roughness: 0.6,
            metalness: 0
        });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // 🌞 Sun Light
        const sunlight = new THREE.PointLight(0xffdd55, 50, 4000);
        scene.add(sunlight);

        // PLANET CREATION FUNCTION
        function createPlanet(size, texture, distance) {
            const geometry = new THREE.SphereGeometry(size, 64, 64);
            const material = new THREE.MeshStandardMaterial({ map: texture });
            const planet = new THREE.Mesh(geometry, material);
            const orbit = new THREE.Group();
            orbit.position.x = distance;
            orbit.add(planet);
            scene.add(orbit);
            return { planet, orbit };
        }

        // 🌍 ENHANCED EARTH & MOON
        const earthGeometry = new THREE.SphereGeometry(1, 64, 64);
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: textures.earth,
            normalMap: textures.earthNormal,
            specularMap: textures.earthSpecular,
            specular: new THREE.Color(0x333333),
            shininess: 25
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        const earthOrbit = new THREE.Group();
        earthOrbit.position.x = 20;
        earthOrbit.add(earth);
        scene.add(earthOrbit);
        const earthData = { planet: earth, orbit: earthOrbit };

        // Earth Clouds
        const earthCloudGeometry = new THREE.SphereGeometry(1.01, 64, 64);
        const earthCloudMaterial = new THREE.MeshPhongMaterial({
            map: textures.earthClouds,
            transparent: true,
            opacity: 0.4
        });
        const earthClouds = new THREE.Mesh(earthCloudGeometry, earthCloudMaterial);
        earth.add(earthClouds);

        // 🌑 ENHANCED MOON
        const moonGeometry = new THREE.SphereGeometry(0.27, 64, 64);
        const moonMaterial = new THREE.MeshPhongMaterial({
            map: textures.moon,
            normalMap: textures.moonNormal,
            roughness: 1,
            metalness: 0
        });
        const moon = new THREE.Mesh(moonGeometry, moonMaterial);
        const moonOrbit = new THREE.Group();
        moonOrbit.position.x = 2.5;
        moonOrbit.add(moon);
        earth.add(moonOrbit);
        const moonData = { planet: moon, orbit: moonOrbit };

        // 🔴 MARS
        const marsData = createPlanet(0.8, textures.mars, 30);

        // 🪐 SATURN
        const saturnData = createPlanet(3, textures.saturn, 60);

        // SATURN RINGS
        const ringGeometry = new THREE.RingGeometry(4, 6, 64);
        const ringMaterial = new THREE.MeshStandardMaterial({
            map: textures.saturnRings,
            side: THREE.DoubleSide,
            transparent: true
        });
        const saturnRings = new THREE.Mesh(ringGeometry, ringMaterial);
        saturnRings.rotation.x = Math.PI / 2;
        saturnData.planet.add(saturnRings);

        // 🌀 JUPITER
        const jupiterData = createPlanet(4, textures.jupiter, 80);

        // ❄️ URANUS
        const uranusData = createPlanet(2.5, textures.uranus, 100);

        // 🌊 NEPTUNE
        const neptuneData = createPlanet(2.5, textures.neptune, 120);

        // 🔅 AMBIENT LIGHT
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // 🎥 CAMERA POSITION
        camera.position.set(0, 0, 50);

        // 🔄 ANIMATION
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Update star positions
            const positions = starField.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 2] += velocities[i / 3];
                if (positions[i + 2] > 1000) {
                    positions[i + 2] = -2000;
                }
            }
            starField.geometry.attributes.position.needsUpdate = true;

            // ROTATIONS
            sun.rotation.y += 0.002;
            earthData.planet.rotation.y += 0.005;
            if (earthClouds) earthClouds.rotation.y += 0.006; // Clouds rotate slightly faster
            marsData.planet.rotation.y += 0.005;
            saturnData.planet.rotation.y += 0.005;
            jupiterData.planet.rotation.y += 0.005;
            uranusData.planet.rotation.y += 0.005;
            neptuneData.planet.rotation.y += 0.005;

            // ORBIT MOVEMENT
            angle += 0.002;
            earthData.orbit.position.x = Math.cos(angle) * 20;
            earthData.orbit.position.z = Math.sin(angle) * 20;

            moonData.orbit.position.x = Math.cos(angle * 5) * 2.5;
            moonData.orbit.position.z = Math.sin(angle * 5) * 2.5;

            marsData.orbit.position.x = Math.cos(angle * 0.8) * 30;
            marsData.orbit.position.z = Math.sin(angle * 0.8) * 30;

            saturnData.orbit.position.x = Math.cos(angle * 0.6) * 60;
            saturnData.orbit.position.z = Math.sin(angle * 0.6) * 60;

            jupiterData.orbit.position.x = Math.cos(angle * 0.4) * 80;
            jupiterData.orbit.position.z = Math.sin(angle * 0.4) * 80;

            uranusData.orbit.position.x = Math.cos(angle * 0.3) * 100;
            uranusData.orbit.position.z = Math.sin(angle * 0.3) * 100;

            neptuneData.orbit.position.x = Math.cos(angle * 0.2) * 120;
            neptuneData.orbit.position.z = Math.sin(angle * 0.2) * 120;

            renderer.render(scene, camera);
        }
        animate();

        // 🖱️ ZOOM IN & OUT
        window.addEventListener('wheel', (event) => {
            camera.position.z += event.deltaY * 0.1;
            camera.position.z = Math.max(10, Math.min(camera.position.z, 300));
        });

        // 📏 RESIZE HANDLING
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });

    </script>
</body>
</html>