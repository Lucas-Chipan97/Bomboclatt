<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underwater Scene with Textures</title>
    <style>
        body { 
            margin: 0; 
            overflow-x: hidden; 
            height: 500vh; /* Allow scrolling for depth effect */
            background: linear-gradient(to bottom, #1e3a5f, #001020);
        }
        canvas { 
            display: block; 
            position: fixed;
            top: 0;
            left: 0;
        }
        .instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
    </style>
    <!-- Load GSAP via CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
</head>
<body>
<div class="instructions">Scroll to dive deeper. Click on the fisherman to cast the line.</div>

<script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js";

    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Texture Loader
    const textureLoader = new THREE.TextureLoader();
    
    // Load Textures
    const waterTexture = textureLoader.load('https://i.ibb.co/JKKrwq2/water-normal.jpg');
    waterTexture.wrapS = THREE.RepeatWrapping;
    waterTexture.wrapT = THREE.RepeatWrapping;
    waterTexture.repeat.set(5, 5);
    
    const sandTexture = textureLoader.load('https://i.ibb.co/KrgSZS1/sand-texture.jpg');
    sandTexture.wrapS = THREE.RepeatWrapping;
    sandTexture.wrapT = THREE.RepeatWrapping;
    sandTexture.repeat.set(10, 10);
    
    const woodTexture = textureLoader.load('https://i.ibb.co/MCn3BWy/wood-texture.jpg');
    
    // Fog (Darker as we go deeper)
    scene.fog = new THREE.FogExp2(0x1e3a5f, 0.05);
    renderer.setClearColor(scene.fog.color);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);
    
    const sunLight = new THREE.DirectionalLight(0x88ccff, 1);
    sunLight.position.set(0, 10, 5);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 1024;
    sunLight.shadow.mapSize.height = 1024;
    scene.add(sunLight);
    
    // Water surface with normal map
    const waterGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
    const waterMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x1e3a5f,
        transparent: true, 
        opacity: 0.8,
        normalMap: waterTexture,
        normalScale: new THREE.Vector2(0.3, 0.3),
        metalness: 0.1,
        roughness: 0.2
    });
    const waterSurface = new THREE.Mesh(waterGeometry, waterMaterial);
    waterSurface.rotation.x = -Math.PI / 2;
    waterSurface.position.y = 1;
    scene.add(waterSurface);

    // Ocean Floor with texture
    const oceanFloor = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100, 20, 20),
        new THREE.MeshStandardMaterial({ 
            color: 0xddddcc, 
            map: sandTexture,
            roughness: 1,
            metalness: 0
        })
    );
    oceanFloor.rotation.x = -Math.PI / 2;
    oceanFloor.position.y = -20;
    oceanFloor.receiveShadow = true;
    scene.add(oceanFloor);

    // Create Boat with Wood Texture
    const createBoat = () => {
        const boatGroup = new THREE.Group();
        
        // Boat Hull
        const hullGeometry = new THREE.BoxGeometry(3, 1, 7);
        const hullMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xbb8866, 
            map: woodTexture,
            roughness: 0.7
        });
        const hull = new THREE.Mesh(hullGeometry, hullMaterial);
        hull.position.y = 0.5;
        hull.castShadow = true;
        boatGroup.add(hull);
        
        // Boat Seat
        const seatGeometry = new THREE.BoxGeometry(2.5, 0.2, 1);
        const seat = new THREE.Mesh(seatGeometry, hullMaterial);
        seat.position.set(0, 1, -2);
        boatGroup.add(seat);
        
        // Boat Details - Rails
        const railGeometry = new THREE.CylinderGeometry(0.05, 0.05, 6.8);
        const railMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd });
        
        const leftRail = new THREE.Mesh(railGeometry, railMaterial);
        leftRail.rotation.x = Math.PI/2;
        leftRail.position.set(-1.4, 1.2, 0);
        boatGroup.add(leftRail);
        
        const rightRail = new THREE.Mesh(railGeometry, railMaterial);
        rightRail.rotation.x = Math.PI/2;
        rightRail.position.set(1.4, 1.2, 0);
        boatGroup.add(rightRail);
        
        boatGroup.position.y = 2;
        return boatGroup;
    };
    
    const boat = createBoat();
    scene.add(boat);

    // Fisherman with more detail
    const createFisherman = () => {
        const fishermanGroup = new THREE.Group();
        
        // Head
        const headGeometry = new THREE.SphereGeometry(0.3);
        const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xe0ac69 });
        const head = new THREE.Mesh(headGeometry, skinMaterial);
        head.position.y = 0.3;
        fishermanGroup.add(head);
        
        // Body
        const bodyGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.8);
        const clothesMaterial = new THREE.MeshStandardMaterial({ color: 0x3b5998 });
        const body = new THREE.Mesh(bodyGeometry, clothesMaterial);
        body.position.y = -0.4;
        fishermanGroup.add(body);
        
        // Hat
        const hatGeometry = new THREE.ConeGeometry(0.35, 0.3);
        const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const hat = new THREE.Mesh(hatGeometry, hatMaterial);
        hat.position.y = 0.6;
        fishermanGroup.add(hat);
        
        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6);
        
        const leftArm = new THREE.Mesh(armGeometry, skinMaterial);
        leftArm.position.set(-0.4, -0.3, 0);
        leftArm.rotation.z = -Math.PI/4;
        fishermanGroup.add(leftArm);
        
        const rightArm = new THREE.Mesh(armGeometry, skinMaterial);
        rightArm.position.set(0.4, -0.3, 0);
        rightArm.rotation.z = Math.PI/4;
        fishermanGroup.add(rightArm);
        
        // Make the entire fisherman clickable
        fishermanGroup.userData.clickable = true;
        
        fishermanGroup.position.set(0, 2.5, -2);
        return fishermanGroup;
    };
    
    const fisherman = createFisherman();
    scene.add(fisherman);

    // Fishing Rod
    const rodGeometry = new THREE.CylinderGeometry(0.02, 0.01, 3);
    const rodMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const fishingRod = new THREE.Mesh(rodGeometry, rodMaterial);
    fishingRod.position.set(0.2, 2.7, -1.5);
    fishingRod.rotation.z = -Math.PI/4;
    scene.add(fishingRod);

    // Fishing Line & Bait
    const lineStartPosition = new THREE.Vector3(0.9, 2.2, -1.5);
    const lineEndPosition = new THREE.Vector3(0.9, 1, -1.5);
    
    const fishingLine = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([lineStartPosition, lineEndPosition]),
        new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 })
    );
    scene.add(fishingLine);

    const bait = new THREE.Mesh(
        new THREE.SphereGeometry(0.15),
        new THREE.MeshStandardMaterial({ color: 0xff9900, metalness: 0.5, roughness: 0.2 })
    );
    bait.position.copy(lineEndPosition);
    bait.castShadow = true;
    scene.add(bait);

    // Add Fish
    const createFish = (color, x, y, z, size) => {
        const fishGroup = new THREE.Group();
        
        // Fish Body
        const bodyGeometry = new THREE.ConeGeometry(size, size*2, 12);
        const bodyMaterial = new THREE.MeshStandardMaterial({ 
            color: color,
            metalness: 0.3,
            roughness: 0.7
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.rotation.z = Math.PI/2;
        fishGroup.add(body);
        
        // Fish Tail
        const tailGeometry = new THREE.ConeGeometry(size*0.8, size, 3);
        const tail = new THREE.Mesh(tailGeometry, bodyMaterial);
        tail.position.x = -size*1.2;
        tail.rotation.z = -Math.PI/2;
        fishGroup.add(tail);
        
        // Fish Eye
        const eyeGeometry = new THREE.SphereGeometry(size*0.15);
        const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(size*0.5, size*0.3, size*0.4);
        fishGroup.add(eye);
        
        const pupilGeometry = new THREE.SphereGeometry(size*0.07);
        const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.set(size*0.55, size*0.3, size*0.45);
        fishGroup.add(pupil);
        
        fishGroup.position.set(x, y, z);
        
        // Add swimming animation
        const randomSpeed = 0.005 + Math.random() * 0.01;
        const randomAmp = 1 + Math.random() * 2;
        
        fishGroup.userData.animation = {
            speed: randomSpeed,
            amplitude: randomAmp,
            originalX: x,
            time: Math.random() * 100
        };
        
        return fishGroup;
    };
    
    const fishes = [];
    for (let i = 0; i < 20; i++) {
        const x = (Math.random() - 0.5) * 40;
        const y = -5 - Math.random() * 15;
        const z = (Math.random() - 0.5) * 40;
        const size = 0.3 + Math.random() * 0.3;
        
        // Random fish color
        const colors = [0xff5500, 0x00aaff, 0xffcc00, 0x00ccaa, 0xff00ff];
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        const fish = createFish(color, x, y, z, size);
        scene.add(fish);
        fishes.push(fish);
    }

    // Add Corals and Underwater Plants
    const createCoral = (x, z) => {
        const coralGroup = new THREE.Group();
        
        const coralGeometry = new THREE.CylinderGeometry(0.1, 0.2, 1.5, 5);
        const coralMaterial = new THREE.MeshStandardMaterial({ 
            color: Math.random() > 0.5 ? 0xff5555 : 0xff55ff,
            roughness: 0.8
        });
        
        const segments = 3 + Math.floor(Math.random() * 5);
        
        for (let i = 0; i < segments; i++) {
            const segment = new THREE.Mesh(coralGeometry, coralMaterial);
            segment.position.set(
                (Math.random() - 0.5) * 0.4,
                0.4 + Math.random() * 0.3,
                (Math.random() - 0.5) * 0.4
            );
            
            // Random rotation for variety
            segment.rotation.x = (Math.random() - 0.5) * 0.5;
            segment.rotation.z = (Math.random() - 0.5) * 0.5;
            
            coralGroup.add(segment);
        }
        
        coralGroup.position.set(x, -19.5, z);
        return coralGroup;
    };
    
    // Add corals to the scene
    for (let i = 0; i < 25; i++) {
        const x = (Math.random() - 0.5) * 40;
        const z = (Math.random() - 0.5) * 40;
        const coral = createCoral(x, z);
        scene.add(coral);
    }

    // Add Bubbles
    const bubbles = [];
    const createBubble = () => {
        const size = 0.05 + Math.random() * 0.15;
        const bubbleGeometry = new THREE.SphereGeometry(size);
        const bubbleMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2,
            metalness: 0.1,
            roughness: 0.1
        });
        
        const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
        
        // Random position near fisherman or random fish
        const source = Math.random() > 0.7 ? fisherman : fishes[Math.floor(Math.random() * fishes.length)];
        const position = source.position.clone();
        
        bubble.position.set(
            position.x + (Math.random() - 0.5),
            position.y - 0.5,
            position.z + (Math.random() - 0.5)
        );
        
        bubble.userData = {
            speed: 0.01 + Math.random() * 0.03,
            wobble: {
                speed: 0.05 + Math.random() * 0.1,
                amplitude: 0.05 + Math.random() * 0.1,
                time: Math.random() * Math.PI * 2
            }
        };
        
        scene.add(bubble);
        bubbles.push(bubble);
        
        // Remove bubble after it reaches the surface
        setTimeout(() => {
            scene.remove(bubble);
            bubbles.splice(bubbles.indexOf(bubble), 1);
        }, 10000);
    };
    
    // Create bubbles occasionally
    setInterval(createBubble, 500);

    // Add seaweed
    const createSeaweed = (x, z, height) => {
        const seaweedGroup = new THREE.Group();
        const segments = 5 + Math.floor(Math.random() * 5);
        const segmentHeight = height / segments;
        
        const points = [];
        for (let i = 0; i < segments + 1; i++) {
            points.push(new THREE.Vector3(0, i * segmentHeight, 0));
        }
        
        const seaweedGeometry = new THREE.TubeGeometry(
            new THREE.CatmullRomCurve3(points),
            segments * 3,
            0.1 - 0.05 * (height / 5),
            8,
            false
        );
        
        const seaweedMaterial = new THREE.MeshStandardMaterial({
            color: 0x00aa44,
            roughness: 0.9,
            metalness: 0.1
        });
        
        const seaweed = new THREE.Mesh(seaweedGeometry, seaweedMaterial);
        seaweed.userData = {
            originalPoints: points.map(p => p.clone()),
            waveParams: {
                speed: 0.5 + Math.random() * 0.5,
                amplitude: 0.1 + Math.random() * 0.2,
                phase: Math.random() * Math.PI * 2
            }
        };
        
        seaweedGroup.add(seaweed);
        seaweedGroup.position.set(x, -20 + height / 2, z);
        
        return seaweedGroup;
    };
    
    const seaweeds = [];
    for (let i = 0; i < 40; i++) {
        const x = (Math.random() - 0.5) * 40;
        const z = (Math.random() - 0.5) * 40;
        const height = 2 + Math.random() * 3;
        
        const seaweed = createSeaweed(x, z, height);
        scene.add(seaweed);
        seaweeds.push(seaweed.children[0]);
    }

    // Initial Camera Position (At the Surface)
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    let scrollY = 0;

    // Scroll Event - Move Camera & Darken Scene
    window.addEventListener("scroll", () => {
        scrollY = window.scrollY * 0.02; // Control scroll speed
        camera.position.y = 5 - scrollY;
        
        // Darken the water as we go deeper
        const depthFactor = Math.min(scrollY / 15, 1);
        scene.fog.color.setRGB(0.12 - depthFactor * 0.1, 0.23 - depthFactor * 0.15, 0.4 - depthFactor * 0.3);
        renderer.setClearColor(scene.fog.color);
        
        // Adjust light intensity based on depth
        sunLight.intensity = Math.max(1 - depthFactor * 0.8, 0.2);
        
        // Update water opacity for surface effect
        if (scrollY < 5) {
            waterSurface.material.opacity = 0.8 - scrollY / 5 * 0.8;
        } else {
            waterSurface.material.opacity = 0;
        }
    });

    // Fisherman Click - Throw Bait Animation
    let isFishing = false;
    
    window.addEventListener("click", (event) => {
        if (isFishing) return;
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        // Check if fisherman or any part of him was clicked
        const clickedFisherman = intersects.some(intersect => {
            return intersect.object.parent === fisherman || 
                  (intersect.object.userData && intersect.object.userData.clickable);
        });

        if (clickedFisherman) {
            isFishing = true;
            
            // Rod animation
            gsap.to(fishingRod.rotation, {
                x: 0.3,
                duration: 0.5,
                yoyo: true,
                repeat: 1
            });
            
            // Bait animation
            gsap.to(bait.position, {
                y: -5 - Math.random() * 10,
                x: lineStartPosition.x + (Math.random() - 0.5) * 2,
                z: lineStartPosition.z + (Math.random() - 0.5) * 2,
                duration: 2,
                ease: "power2.out",
                onUpdate: () => {
                    fishingLine.geometry.setFromPoints([
                        lineStartPosition,
                        bait.position
                    ]);
                },
                onComplete: () => {
                    // Wait for a bit before reeling in
                    setTimeout(() => {
                        // Create bubbles around bait to signal fish interest
                        for (let i = 0; i < 10; i++) {
                            setTimeout(() => {
                                const bubbleGeometry = new THREE.SphereGeometry(0.05 + Math.random() * 0.1);
                                const bubbleMaterial = new THREE.MeshStandardMaterial({
                                    color: 0xffffff,
                                    transparent: true,
                                    opacity: 0.2
                                });
                                
                                const bubble = new THREE.Mesh(bubbleGeometry, bubbleMaterial);
                                bubble.position.copy(bait.position);
                                bubble.position.x += (Math.random() - 0.5) * 0.5;
                                bubble.position.y += Math.random() * 0.5;
                                bubble.position.z += (Math.random() - 0.5) * 0.5;
                                
                                bubble.userData = {
                                    speed: 0.02 + Math.random() * 0.03,
                                    wobble: {
                                        speed: 0.05 + Math.random() * 0.1,
                                        amplitude: 0.05 + Math.random() * 0.1,
                                        time: Math.random() * Math.PI * 2
                                    }
                                };
                                
                                scene.add(bubble);
                                bubbles.push(bubble);
                            }, i * 100);
                        }
                        
                        // Reel in animation
                        gsap.to(bait.position, {
                            y: lineStartPosition.y,
                            x: lineStartPosition.x,
                            z: lineStartPosition.z,
                            duration: 3,
                            ease: "power1.in",
                            onUpdate: () => {
                                fishingLine.geometry.setFromPoints([
                                    lineStartPosition,
                                    bait.position
                                ]);
                            },
                            onComplete: () => {
                                isFishing = false;
                            }
                        });
                    }, 2000 + Math.random() * 3000);
                }
            });
        }
    });

    // Animate Scene
    function animate() {
        requestAnimationFrame(animate);
        
        // Animate water surface
        const time = Date.now() * 0.001;
        if (waterSurface.material.normalScale) {
            waterSurface.material.normalScale.x = 0.5 + Math.sin(time) * 0.2;
            waterSurface.material.normalScale.y = 0.5 + Math.cos(time) * 0.2;
        }
        
        // Animate fish
        fishes.forEach(fish => {
            const animation = fish.userData.animation;
            animation.time += animation.speed;
            
            // Fish swimming motion
            fish.position.x = animation.originalX + Math.sin(animation.time) * animation.amplitude;
            
            // Slight up and down motion
            fish.position.y += Math.sin(animation.time * 0.5) * 0.01;
            
            // Fish rotation to follow movement direction
            fish.rotation.y = Math.sin(animation.time) * 0.25;
            fish.rotation.z = Math.sin(animation.time * 0.5) * 0.1;
        });
        
        // Animate bubbles
        bubbles.forEach(bubble => {
            bubble.position.y += bubble.userData.speed;
            
            // Bubble wobble
            const wobble = bubble.userData.wobble;
            wobble.time += wobble.speed;
            bubble.position.x += Math.sin(wobble.time) * wobble.amplitude * 0.05;
            bubble.position.z += Math.cos(wobble.time) * wobble.amplitude * 0.05;
        });
        
        // Animate seaweed
        seaweeds.forEach(seaweed => {
            const params = seaweed.userData.waveParams;
            const originalPoints = seaweed.userData.originalPoints;
            const newCurvePoints = [];
            
            originalPoints.forEach((point, index) => {
                if (index === 0) {
                    newCurvePoints.push(point.clone());
                    return;
                }
                
                const waveStrength = index / originalPoints.length;
                const offset = Math.sin(time * params.speed + params.phase) * params.amplitude * waveStrength;
                
                const newPoint = point.clone();
                newPoint.x += offset;
                newCurvePoints.push(newPoint);
            });
            
            // Update the seaweed geometry
            const newCurve = new THREE.CatmullRomCurve3(newCurvePoints);
            seaweed.geometry = new THREE.TubeGeometry(
                newCurve,
                seaweed.geometry.parameters.tubularSegments,
                seaweed.geometry.parameters.radius,
                seaweed.geometry.parameters.radialSegments,
                false
            );
        });
        
        // Boat gentle rocking
        boat.rotation.z = Math.sin(time * 0.5) * 0.05;
        boat.rotation.x = Math.sin(time * 0.7) * 0.03;
        
        // Render scene
        renderer.render(scene, camera);
    }

    animate();

    // Resize Handling
    window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>

</body>
</html>